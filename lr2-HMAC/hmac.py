#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Python 3.12.6

# Разработать консольное приложение, реализующее
# шифрование/расшифрование файла с имитовставкой. В работе использовать:
# ● симметричный алгоритм шифрования AES-256 в режиме CFB;
# ● алгоритм генерации имитовставки HMAC;
# ● хэш-функцию SHA-256.
# Алгоритм выполнения шифрования с имитовставкой:
# 1. На основе хеша полученных от пользователя данных вырабатывается ключ:
# a. с помощью случайных данных генерируется “соль”;
# b. формируется ключ
# i. вариант 1:
# 1. “соль” конкатенируется с парольной фразой пользователя;
# 2. берется хэш от полученных данных: SHA256(salt +
# password).
# ii. вариант 2: PBKDF2
# 2. Случайным образом вырабатывается инициализирующий вектор.
# 3. Одновременно с шифрованием файла вырабатывается имитовставка по
# алгоритму HMAC от открытого текста.
# 4. Все необходимые для расшифрования данные записываются в файл подряд
# без разделителей в бинарном виде. Формат файла следующий:
# [соль(32Б)][HMAC(32Б)][инициализирующий вектор(16Б)][шифротекст]
# 5. Производится расшифрование данных из файла, выводится результат проверки
# HMAC.
# Для генерации “соли” можно использовать свой метод или один из следующих:
# ● накопление последних бит кодов нажимаемых пользователем кнопок;
# ● накопление последних бит от координат пикселя, находящегося под курсором
# пользователя;
# ● накопление последних бит от значений одного или нескольких цветовых
# каналов пикселя, находящегося под курсором.


# Требования к консольному приложению
# Консольное приложение должно иметь два режима:
# ● шифрование файла;
# ● расшифрование файла с последующим подтверждением целостности данных.
# Консольное приложение должно принимать на вход следующие аргументы:
# ● имя файла для шифрования/расшифрования;
# ● имя файла для сохранения зашифрованного/расшифрованного файла;
# ● (опционально) отключение проверки целостности, по умолчанию проверка
# целостности включена.
# Приветствуется использование аргументов командной строки для передачи
# вышеописанных параметров. Наличие интерактивного режима не обязательно - при
# его отсутствии или при запуске с неверными аргументами приложение должно
# показывать инструкцию по использованию.
# После успешного запуска в любом из режимов приложение должно
# сгенерировать ключ шифрования. Для этого необходимы следующие компоненты:
# ● парольная фраза. Пользователь должен ввести парольную фразу в консоль,
# при этом необходимо использовать такие методы, как console.readPassword в
# JAVA, или специальные модули, например read в NodeJS;
# ● модификатор ключа. Пользователь должен предоставить программе случайные
# данные для генерации “соли” при шифровании файла. На этом этапе должен
# происходить сбор данных (пользователь перемещает курсор по экрану,
# нажимает случайные клавиши на клавиатуре и т.д.) до тех пор, пока “соль” не
# будет сгенерирована или пользователь не остановит выполнение программы.
# При расшифровании соль берется из предоставленного для расшифровки
# файла.
# После того, как все необходимые данные для выполнения операции получены,
# необходимо зашифровать/расшифровать файл и в случае расшифрования произвести
# проверку целостности следующим образом:
# ● сгенерировать на основе имеющихся данных (расшифрованного текста,
# парольной фразы и модификатора ключа) имитовставку;
# ● сравнить с имитовставкой, предоставленной в файле.
# В случае подтверждения факта искажения данных сохранять расшифрованный
# файл не обязательно.


import hashlib
import hmac
import os
import random
import argparse

import tqdm
import pyautogui
from PIL import ImageGrab
import colorama as clr


def get_mouse_pixel_data():
    # Get the current mouse position
    x, y = pyautogui.position()

    # Capture the screen at the mouse position
    screen = ImageGrab.grab(bbox=(x, y, x+1, y+1))

    # Get the RGB value of the pixel
    pixel = screen.load()
    r, g, b = pixel[0, 0]

    return x, y, r, g, b


def get_salt(byte_len) -> int:
    salt = 0
    bitlen = byte_len * 8
    prev_x, prev_y, prev_r, prev_g, prev_b = None, None, None, None, None
    print(f'{clr.Fore.YELLOW}Getting salt. {
        '\033[4m'}Move the mouse around the screen.{clr.Style.RESET_ALL}')
    # for _ in range((bitlen // 5) + 1):
    for _ in tqdm.tqdm(range((bitlen // 5) + 1), desc='Getting salt'):
        while True:
            x, y, r, g, b = get_mouse_pixel_data()
            if (x, y, r, g, b) != (prev_x, prev_y, prev_r, prev_g, prev_b):
                prev_x, prev_y, prev_r, prev_g, prev_b = x, y, r, g, b
                salt = (salt << 1) | (x & 0x01)
                salt = (salt << 1) | (y & 0x01)
                salt = (salt << 1) | (r & 0x01)
                salt = (salt << 1) | (g & 0x01)
                salt = (salt << 1) | (b & 0x01)
                # print last 5 bits in binary, with leading zeros
                # print(f'{salt & 0x1F:05b}', end='\r')
                bitlen -= 5
                break
    # cut the excessive bits
    salt = salt >> (bitlen * -1)
    return salt


def count_zeros_ones_binary(num):
    zeros = 0
    ones = 0
    while num:
        if num & 1:
            ones += 1
        else:
            zeros += 1
        num >>= 1
    return zeros, ones


if __name__ == "__main__":
    salt = get_salt(32)
    print(hex(salt))
    print(bin(salt))
    print(count_zeros_ones_binary(salt), sum(count_zeros_ones_binary(salt)))
